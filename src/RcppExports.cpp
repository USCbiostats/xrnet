// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppEigen.h>
#include <Rcpp.h>

using namespace Rcpp;

#ifdef RCPP_USE_GLOBAL_ROSTREAM
Rcpp::Rostream<true>&  Rcpp::Rcout = Rcpp::Rcpp_cout_get();
Rcpp::Rostream<false>& Rcpp::Rcerr = Rcpp::Rcpp_cerr_get();
#endif

// computeResponseRcpp
Eigen::MatrixXd computeResponseRcpp(SEXP X, const int& mattype_x, const Eigen::Map<Eigen::MatrixXd> Fixed, const Eigen::Map<Eigen::VectorXd> beta0, const Eigen::Map<Eigen::MatrixXd> betas, const Eigen::Map<Eigen::MatrixXd> gammas, const std::string& response_type, const std::string& family);
RcppExport SEXP _xrnet_computeResponseRcpp(SEXP XSEXP, SEXP mattype_xSEXP, SEXP FixedSEXP, SEXP beta0SEXP, SEXP betasSEXP, SEXP gammasSEXP, SEXP response_typeSEXP, SEXP familySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type X(XSEXP);
    Rcpp::traits::input_parameter< const int& >::type mattype_x(mattype_xSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type Fixed(FixedSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type beta0(beta0SEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type betas(betasSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type gammas(gammasSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type response_type(response_typeSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type family(familySEXP);
    rcpp_result_gen = Rcpp::wrap(computeResponseRcpp(X, mattype_x, Fixed, beta0, betas, gammas, response_type, family));
    return rcpp_result_gen;
END_RCPP
}
// fitModelCVRcpp
Eigen::VectorXd fitModelCVRcpp(SEXP x, const int mattype_x, const Eigen::Map<Eigen::MatrixXd> y, SEXP ext, const bool& is_sparse_ext, const Eigen::Map<Eigen::MatrixXd> fixed, Eigen::VectorXd weights_user, const Rcpp::LogicalVector& intr, const Rcpp::LogicalVector& stnd, const Eigen::Map<Eigen::VectorXd> penalty_type, const Eigen::Map<Eigen::VectorXd> cmult, const Eigen::Map<Eigen::VectorXd> quantiles, const Rcpp::IntegerVector& num_penalty, const Rcpp::NumericVector& penalty_ratio, const Eigen::Map<Eigen::VectorXd> penalty_user, const Eigen::Map<Eigen::VectorXd> penalty_user_ext, Eigen::VectorXd lower_cl, Eigen::VectorXd upper_cl, const std::string& family, const std::string& user_loss, const Eigen::Map<Eigen::VectorXi> test_idx, const double& thresh, const int& maxit, const int& ne, const int& nx);
RcppExport SEXP _xrnet_fitModelCVRcpp(SEXP xSEXP, SEXP mattype_xSEXP, SEXP ySEXP, SEXP extSEXP, SEXP is_sparse_extSEXP, SEXP fixedSEXP, SEXP weights_userSEXP, SEXP intrSEXP, SEXP stndSEXP, SEXP penalty_typeSEXP, SEXP cmultSEXP, SEXP quantilesSEXP, SEXP num_penaltySEXP, SEXP penalty_ratioSEXP, SEXP penalty_userSEXP, SEXP penalty_user_extSEXP, SEXP lower_clSEXP, SEXP upper_clSEXP, SEXP familySEXP, SEXP user_lossSEXP, SEXP test_idxSEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP neSEXP, SEXP nxSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int >::type mattype_x(mattype_xSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type y(ySEXP);
    Rcpp::traits::input_parameter< SEXP >::type ext(extSEXP);
    Rcpp::traits::input_parameter< const bool& >::type is_sparse_ext(is_sparse_extSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type fixed(fixedSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights_user(weights_userSEXP);
    Rcpp::traits::input_parameter< const Rcpp::LogicalVector& >::type intr(intrSEXP);
    Rcpp::traits::input_parameter< const Rcpp::LogicalVector& >::type stnd(stndSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_type(penalty_typeSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type cmult(cmultSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type quantiles(quantilesSEXP);
    Rcpp::traits::input_parameter< const Rcpp::IntegerVector& >::type num_penalty(num_penaltySEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type penalty_ratio(penalty_ratioSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_user(penalty_userSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_user_ext(penalty_user_extSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type lower_cl(lower_clSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type upper_cl(upper_clSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type family(familySEXP);
    Rcpp::traits::input_parameter< const std::string& >::type user_loss(user_lossSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXi> >::type test_idx(test_idxSEXP);
    Rcpp::traits::input_parameter< const double& >::type thresh(threshSEXP);
    Rcpp::traits::input_parameter< const int& >::type maxit(maxitSEXP);
    Rcpp::traits::input_parameter< const int& >::type ne(neSEXP);
    Rcpp::traits::input_parameter< const int& >::type nx(nxSEXP);
    rcpp_result_gen = Rcpp::wrap(fitModelCVRcpp(x, mattype_x, y, ext, is_sparse_ext, fixed, weights_user, intr, stnd, penalty_type, cmult, quantiles, num_penalty, penalty_ratio, penalty_user, penalty_user_ext, lower_cl, upper_cl, family, user_loss, test_idx, thresh, maxit, ne, nx));
    return rcpp_result_gen;
END_RCPP
}
// fitModelRcpp
Rcpp::List fitModelRcpp(SEXP x, const int& mattype_x, const Eigen::Map<Eigen::MatrixXd> y, SEXP ext, const bool& is_sparse_ext, const Eigen::Map<Eigen::MatrixXd> fixed, Eigen::VectorXd weights_user, const Rcpp::LogicalVector& intr, const Rcpp::LogicalVector& stnd, const Eigen::Map<Eigen::VectorXd> penalty_type, const Eigen::Map<Eigen::VectorXd> cmult, const Eigen::Map<Eigen::VectorXd> quantiles, const Rcpp::IntegerVector& num_penalty, const Rcpp::NumericVector& penalty_ratio, const Eigen::Map<Eigen::VectorXd> penalty_user, const Eigen::Map<Eigen::VectorXd> penalty_user_ext, Eigen::VectorXd lower_cl, Eigen::VectorXd upper_cl, const std::string& family, const double& thresh, const int& maxit, const int& ne, const int& nx);
RcppExport SEXP _xrnet_fitModelRcpp(SEXP xSEXP, SEXP mattype_xSEXP, SEXP ySEXP, SEXP extSEXP, SEXP is_sparse_extSEXP, SEXP fixedSEXP, SEXP weights_userSEXP, SEXP intrSEXP, SEXP stndSEXP, SEXP penalty_typeSEXP, SEXP cmultSEXP, SEXP quantilesSEXP, SEXP num_penaltySEXP, SEXP penalty_ratioSEXP, SEXP penalty_userSEXP, SEXP penalty_user_extSEXP, SEXP lower_clSEXP, SEXP upper_clSEXP, SEXP familySEXP, SEXP threshSEXP, SEXP maxitSEXP, SEXP neSEXP, SEXP nxSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< const int& >::type mattype_x(mattype_xSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type y(ySEXP);
    Rcpp::traits::input_parameter< SEXP >::type ext(extSEXP);
    Rcpp::traits::input_parameter< const bool& >::type is_sparse_ext(is_sparse_extSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::MatrixXd> >::type fixed(fixedSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type weights_user(weights_userSEXP);
    Rcpp::traits::input_parameter< const Rcpp::LogicalVector& >::type intr(intrSEXP);
    Rcpp::traits::input_parameter< const Rcpp::LogicalVector& >::type stnd(stndSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_type(penalty_typeSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type cmult(cmultSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type quantiles(quantilesSEXP);
    Rcpp::traits::input_parameter< const Rcpp::IntegerVector& >::type num_penalty(num_penaltySEXP);
    Rcpp::traits::input_parameter< const Rcpp::NumericVector& >::type penalty_ratio(penalty_ratioSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_user(penalty_userSEXP);
    Rcpp::traits::input_parameter< const Eigen::Map<Eigen::VectorXd> >::type penalty_user_ext(penalty_user_extSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type lower_cl(lower_clSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type upper_cl(upper_clSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type family(familySEXP);
    Rcpp::traits::input_parameter< const double& >::type thresh(threshSEXP);
    Rcpp::traits::input_parameter< const int& >::type maxit(maxitSEXP);
    Rcpp::traits::input_parameter< const int& >::type ne(neSEXP);
    Rcpp::traits::input_parameter< const int& >::type nx(nxSEXP);
    rcpp_result_gen = Rcpp::wrap(fitModelRcpp(x, mattype_x, y, ext, is_sparse_ext, fixed, weights_user, intr, stnd, penalty_type, cmult, quantiles, num_penalty, penalty_ratio, penalty_user, penalty_user_ext, lower_cl, upper_cl, family, thresh, maxit, ne, nx));
    return rcpp_result_gen;
END_RCPP
}

static const R_CallMethodDef CallEntries[] = {
    {"_xrnet_computeResponseRcpp", (DL_FUNC) &_xrnet_computeResponseRcpp, 8},
    {"_xrnet_fitModelCVRcpp", (DL_FUNC) &_xrnet_fitModelCVRcpp, 25},
    {"_xrnet_fitModelRcpp", (DL_FUNC) &_xrnet_fitModelRcpp, 23},
    {NULL, NULL, 0}
};

RcppExport void R_init_xrnet(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
